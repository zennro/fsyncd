#!/usr/bin/perl

# fsyncd/linux/fsyncd
# Copyright (C) 2012 Shaun Landis
# This code is free to be modified and distributed however you please.
# There is no warranty, written nor implied.

# Watch a path(s) via inotify and rsync to a host on a timed (local->remote)
# and event-queue (local<-remote) driven basis.

# This is messy, and could be better. Enough said.

use Linux::Inotify2;
use Getopt::Long;
use File::Basename;

my $log = 0;
my $daemon = 1;
my %opts = ('log' => \$log, 'daemon' => \$daemon);
$opts{delay} = 0;
$opts{queue} = 1;

GetOptions(\%opts, 'source=s', 'target=s', 'delay=i', 'queue=i', 'log', 'daemon!');

# Some simple sanity checks
if (!exists($opts{source}) || !exists($opts{target})) {
  die("You must specify a source and a target!");
}

if ($daemon) {
  # We don't want to dump data if we're fork()ing
  $log = 0;
  my $pid = fork();

  if ($pid) {
    exit(0);
  } else {
    setpgrp;
  }
}

my ($source, $base) = fileparse($opts{source});
my ($host, $target) = split(/:/, $opts{target});

my $last = time;
my $remote = 0;
my $queue = 0;
my $rsync = 0;

# Does a remote->local sync
sub remote_sync {
  $last = time;
  $rsync = 1;
  $remote = 1;

  if ($log) {
    printf "[%s] <- rsync %s:%s %s\n", time, $host, $target, $base;
  }
  
  system("rsync -auz --delete-before --no-perms --exclude .index $host:$target $base");
  $rsync = 0;
}

# Does a local->remote sync
sub local_sync {
  $events = 0;
  $rsync = 1;
    
  if ($log) {
    printf "[%d] -> rsync %s/%s %s:\n", time, $base, $source, $host;
  }
  
  system("rsync -auz --delete-before --no-perms --exclude .index $base/$source $host:");
  $rsync = 0;
}

# Perform an initial remote->local sync to get the base
remote_sync;

# Setup the watch structure and begin
my $pool = new Linux::Inotify2 or die;

# Set non-blocking mode on the fd
$pool->blocking(0);
$pool->watch("$base/$source", IN_MODIFY|IN_MOVE|IN_CLOSEWRITE|IN_DELETE|IN_CREATE|IN_MOVE_SELF);

while () {
  # We just performed a local<-remote sync, so we have no need to catch the events here..
  if ($remote) {
    $remote = 0;
    next;
  }

  # We only want to execute the rsync after we've filled the queue. This is a non-blocking read.
  my @events = $pool->read;
  foreach $e (@events) {
    $queue++;
  }

  # Perform the rsync operation, but only if we're not currently running something already.
  if ($queue >= $opts{queue}) {
    if (!$rsync) {
      local_sync;
      $queue = 0;
    }
  }

  if ($opts{delay} && $last+$opts{delay} <= time) {
    # Do it.
    remote_sync;
  }

  sleep(1);
}
