#!/usr/bin/perl

# fsyncd/mac/fsyncd
# Copyright (C) 2012 Shaun Landis
# This code is free to be modified and distributed however you please.
# There is no warranty, written nor implied.

# Watch a path(s) via fsevets and rsync to a host on a timed (local->remote)
# and event-queue (local<-remote) driven basis.

# This is messy, and could be better. Enough said.

use Mac::FSEvents qw(:flags);
use Getopt::Long;
use File::Basename;
use IO::Select;

my $log = 0;
my $daemon = 1;
my %opts = ('log' => \$log, 'daemon' => \$daemon);
$opts{delay} = 0;
$opts{queue} = 1;

GetOptions(\%opts, 'source=s', 'target=s', 'delay=i', 'queue=i', 'log', 'daemon!');

# Some simple sanity checks
if (!exists($opts{source}) || !exists($opts{target})) {
  die("You must specify a source and a target!");
}

if ($daemon) {
  # We don't want to dump data if we're fork()ing
  $log = 0;
  my $pid = fork();

  if ($pid) {
    exit(0);
  } else {
    setpgrp;
  }
}

my ($source, $base) = fileparse($opts{source});
my ($host, $target) = split(/:/, $opts{target});

my $last = time;
my $remote = 0;
my $queue = 0;
my $rsync = 0;

# Does a remote->local sync
sub remote_sync {
  $last = time;
  $rsync = 1;
  $remote = 1;

  if ($log) {
    printf "[%s] <- rsync %s:%s %s\n", time, $host, $target, $base;
  }
  
  system("rsync -auz --delete-before --no-perms --exclude .index $host:$target $base");
  $rsync = 0;
}

# Does a local->remote sync
sub local_sync {
  $events = 0;
  $rsync = 1;
    
  if ($log) {
    printf "[%d] -> rsync %s/%s %s:\n", time, $base, $source, $host;
  }
  
  system("rsync -auz --delete-before --no-perms --exclude .index $base/$source $host:");
  $rsync = 0;
}

# Perform an initial remote->local sync to get the base
local_sync;
remote_sync;

my $pool = Mac::FSEvents->new({
      path    =>  $base.'/'.$source,
      flags   => FILE_EVENTS,
  });

my $select = IO::Select->new($pool->watch) or die;

use constant FSE_NONE		=> 0x00000000;
use constant FSE_CREATED	=> 0x00000100;
use constant FSE_REMOVED	=> 0x00000200;
use constant FSE_RENAMED	=> 0x00000800;
use constant FSE_MODIFIED	=> 0x00001000;
use constant FSE_ISFILE		=> 0x00010000;
use constant FSE_ISDIR		=> 0x00020000;
use constant FSE_ISLINK		=> 0x00040000;

my $flags = FSE_CREATED | FSE_REMOVED | FSE_RENAMED | FSE_MODIFIED | FSE_ISDIR | FSE_ISFILE;

while () {
	# We just performed a local<-remote sync, so we have no need to catch the events here..
 	if ($remote) {
		$remote = 0;
		next;
	}

	if ($select->can_read(1)) {
	    for my $event ($pool->read_events) {
	        if ($event->flags & $flags) {
	        	$queue++;
	        }
	    }
	}

	# Perform the rsync operation, but only if we're not currently running something already.
    if ($queue >= $opts{queue}) {
        if (!$rsync) {
            local_sync;
            $queue = 0;
        }
    }

    if ($opts{delay} && $last+$opts{delay} <= time) {
        # Do it.
        remote_sync;
    }

    sleep(1);
}
